#! /usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import requests
import json
import os
import pandas as pd  # 用于表格显示
import json
import yaml

CONFIG_FILE = 'config.json'

def load_config():
    """加载配置文件"""
    if not os.path.exists(CONFIG_FILE):
        return {"swagger": "", "url": "", "token": ""}
    
    with open(CONFIG_FILE, 'r') as file:
        return json.load(file)

def save_config(config):
    """保存配置文件"""
    with open(CONFIG_FILE, 'w') as file:
        json.dump(config, file, indent=2)

def load_swagger_json(url):
    """从 Swagger JSON 加载 API 定义"""
    response = requests.get(url)
    response.raise_for_status()
    return response.json()

import argparse
import json

def api_request_proc(args):
    # 处理请求的函数，具体实现取决于你的需求
    print("执行 API 请求:", args)

def api_command_proc(args):
    # 处理请求的函数，具体实现取决于你的需求
    args.parser.print_help()

def get_param_type(param):
    # 获取 schema 中的 anyOf
    any_of = param.get("schema", {}).get("anyOf", [])
    
    # 遍历 anyOf 中的类型
    for option in any_of:
        if "type" in option:
            if option["type"] != "null":
                return option["type"]  # 返回第一个找到的类型
        
    return param.get("schema",{}).get('type','string')

def generate_cli_commands(api_data, subparsers):

    parent_tree = {}
    # 遍历 API 路径
    for path, methods in api_data['paths'].items():
        # 将路径按 '/' 分割
        path_parts = path.strip('/').split('/')
        
        # 父级命令解析器
        parent_subparsers = subparsers
        parentkey = ''
        first_method = next(iter(methods.items()), (None, {}))  # 获取第一个项，并处理默认值
        tags = first_method[1].get("tags", [])  # 获取 tags，默认为空列表
        tag = tags[0] if tags else ""  # 获取第一个 tag，若无则为空字符串        
        
        # 遍历路径部分，创建父级命令
        for partfull in path_parts[:-1]:  # 所有部分，除了最后一个
            part = partfull.strip('{').strip('}').replace('_','')
            parentkey = f'{parentkey}_{part}'
            if parentkey in parent_tree:
                 parent_subparsers = parent_tree.get(parentkey)
            else:
                # 创建或获取子命令
                parser = parent_subparsers.add_parser(part, help=f"[{tag} - {parentkey.replace('_','/')}]" )
                parser.set_defaults(func=api_command_proc, parser=parser)

                parent_subparsers = parser.add_subparsers(dest="subcommand")
                parent_tree[parentkey] = parent_subparsers

        # 处理每个 HTTP 方法
        for method, details in methods.items():
            # 获取最后一个路径部分作为子命令
            part = path_parts[-1].strip('{').strip('}').replace('_','')
            command_name = part+f'{method.lower()[0]}'
            command_parser = parent_subparsers.add_parser(command_name, help=f"{details.get('summary', '')}")
            command_parser.description = f"[{method}],{details.get('summary', '')},{details.get('description', '')}"
            
            # 处理查询参数
            paramwhere = {}
            paramrequired = {}
            if 'parameters' in details:
                for param in details['parameters']:
                    # 获取参数名称、帮助信息和类型
                    param_name = param['name']
                    type = get_param_type(param)
                    param_type = str
                    if type == 'integer':
                        param_type = int
                    elif type == 'boolean':
                        param_type = bool
                    param_help = f"[{type}],{param.get('summary', '')},{param.get('description', '')}"
                    if param['in'] == 'query':
                        paramwhere[param_name] = param['in']
                        # 判断参数是否可选
                        if 'required' in param and param['required']:
                            paramrequired[param_name] = True
                            command_parser.add_argument(f'-{param_name}', type=param_type, help=param_help)
                        else:
                            paramrequired[param_name] = False
                            command_parser.add_argument(f'--{param_name}', type=param_type, help=param_help)
                    elif param['in'] == 'path':
                        paramrequired[param_name] = True
                        paramwhere[param_name] = param['in']
                        command_parser.add_argument(f'-{param_name}', type=param_type, help=param_help)

            # 添加参数
            if 'requestBody' in details:
                paramrequired['body'] = True
                command_parser.add_argument('-json', type=json.loads, default={}, help='Request body in JSON format or JSON file path')
            command_parser.add_argument('--out', help='Output file for the result')

            # 设置处理函数
            command_parser.set_defaults(func=api_request_proc, parser=parser, paramwhere=paramwhere, paramrequired=paramrequired, method=method, path=path)


def build_request(command, params, token, api_prefix, json_body):
    """构建 HTTP 请求"""
    method = command['method']
    url = f"{api_prefix}{command['path']}"

    headers = {'Authorization': f'Bearer {token}'}
    response = None

    if method == 'GET':
        response = requests.get(url, headers=headers, params=params)
    elif method == 'POST':
        response = requests.post(url, headers=headers, json=json_body)
    elif method == 'PUT':
        response = requests.put(url, headers=headers, json=json_body)
    elif method == 'DELETE':
        response = requests.delete(url, headers=headers, params=params)
    else:
        raise ValueError(f"Unsupported method: {method}")

    response.raise_for_status()
    return response.json()

def output_to_table(data, output_file):
    """将输出写入表格格式"""
    df = pd.DataFrame(data)
    if output_file:
        df.to_csv(output_file, index=False)
    print(df)

def config_command(args):
    config = load_config()
    hasChange = False
    if args.swagger:
        config['swagger'] = args.swagger
        hasChange = True
    if args.url:
        config['url'] = args.url
        hasChange = True
    if args.token:
        config['token'] = args.token
        hasChange = True
    if not hasChange:
        print(yaml.dump(config, allow_unicode=True))
        args.parser.print_help()
        return
    # 保存更新后的配置
    save_config(config)
    print(yaml.dump(config, allow_unicode=True))
    print("Configuration saved.")
    pass  # 占位符

def main():
    parser = argparse.ArgumentParser(description='rcli - CLI for Swagger API',add_help=True)
    subparsers = parser.add_subparsers(dest='command')

    # Config command
    config_parser = subparsers.add_parser('config', help='Configure CLI settings')
    config_parser.add_argument('--swagger', help='Swagger JSON URL')
    config_parser.add_argument('--url', help='API prefix URL')
    config_parser.add_argument('--token', help='OAuth2 Token')
    config_parser.set_defaults(func=config_command, parser=config_parser)  # 绑定处理函数

    config = load_config()
    # 加载 Swagger JSON
    swagger_json = load_swagger_json(config['swagger'])
    # 生成 CLI 命令
    generate_cli_commands(swagger_json,subparsers)

    args = parser.parse_args()
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()
    
    # # Handle config command
    # if args.command == 'api':
    #     # 加载配置
    #     config = load_config()

    #     # 加载 Swagger JSON
    #     swagger_json = load_swagger_json(config['swagger'])

    #     # 生成 CLI 命令
    #     commands = generate_cli_commands(swagger_json)

    #     # 创建多级命令结构
    #     command_structure = create_command_structure(commands)

    #     # 添加多级子命令
    #     api_parser = subparsers.add_parser('api', help='Call API based on Swagger')
    #     add_subparsers(api_parser, commands)

    #     # 解析 API 子命令
    #     api_args = api_parser.parse_args()

    #     # 验证路径是否存在
    #     if api_args.subcommand not in command_structure:
    #         raise ValueError(f"Path {api_args.subcommand} not found in Swagger JSON")

    #     command = command_structure[api_args.subcommand]
    #     api_prefix = config['url']
    #     response_data = build_request(command, api_args.params, config['token'], api_prefix, api_args.json)

    #     # 输出结果
    #     output_to_table(response_data, api_args.out)

if __name__ == '__main__':
    main()